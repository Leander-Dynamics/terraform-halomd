## Azure DevOps CI/CD Pipeline for HaloMD Arbit (parameterised per environment)

# This pipeline defines the CI/CD stages for the Arbit project and supports
# multiple environments (dev, stage and prod) using a single YAML file.  It
# leverages Azure DevOps variable groups to supply common values (via
# `terraform-global-common`) and environment‑specific values (via
# `terraform-dev`, `terraform-stage` or `terraform-prod`).  To add a new
# environment you simply create the corresponding variable group and add its
# name to the `envName` parameter values.
#
# The remote backend configuration for each environment is derived from
# variables at runtime.  For the dev and stage environments, the backend
# resource group is fixed (`dev-eus2-ops-rg-1`).  For production, the
# resource group follows the pattern `<envName>-<location>-ops-rg-1`.  The
# storage account name is built as `st<envName>tfstate<location>` and
# converted to lower case to satisfy Azure naming rules (storage account
# names may not include dashes).  The container name is `<envName>-tfstate`
# and may include a dash.  The key is `arbit/<envName>.tfstate`.

# The pipeline has three stages:
# 1. **Bootstrap** – Ensures the backend resource group, storage account,
#    container and optional Key Vault exist.  This stage is idempotent and
#    safe to run multiple times.  It uses Azure CLI tasks for the resource
#    provisioning.
# 2. **Plan** – Performs `terraform init`, `validate` and `plan` against
#    `envs/<envName>` using the dynamically computed backend configuration.
#    The plan is published as an artifact.
# 3. **Apply** – Downloads the plan and applies it.  In state‑only mode
#    (when `create_app_stack` is not set to true in the environment's
#    `terraform.tfvars`), the apply completes without creating additional
#    resources.

trigger:
- main

pr:
- main
- feature/*

parameters:
- name: envName
  displayName: Environment
  type: string
  default: dev
  values:
  - dev
  - stage
  - prod

# Pull in variable groups.  The common group is always included.  The
# environment‑specific group is selected based on the `envName` parameter.
variables:
- group: terraform-global-common
# Dynamically import the appropriate environment group
- ${{ if eq(parameters.envName, 'dev') }}:
  - group: terraform-dev
- ${{ if eq(parameters.envName, 'stage') }}:
  - group: terraform-stage
- ${{ if eq(parameters.envName, 'prod') }}:
  - group: terraform-prod

pool:
  vmImage: ubuntu-latest

stages:
# -------------------------------------------------------------------------
# Bootstrap stage: create the remote state backend for the selected env
# -------------------------------------------------------------------------
- stage: Bootstrap
  displayName: "Bootstrap: tfstate backend (env: ${{ parameters.envName }})"
  jobs:
  - job: bootstrap
    displayName: "Create tfstate backend (env: ${{ parameters.envName }})"
    steps:
    - checkout: self

    # Install Terraform only if necessary
    - bash: |
        set -euo pipefail
        TFV="${TF_VERSION:-1.9.5}"
        if ! command -v terraform >/dev/null 2>&1 || ! terraform version | head -1 | grep -q "v${TFV}"; then
          sudo apt-get update -y && sudo apt-get install -y unzip curl
          curl -fsSL -o /tmp/tf.zip "https://releases.hashicorp.com/terraform/${TFV}/terraform_${TFV}_linux_amd64.zip"
          sudo unzip -o /tmp/tf.zip -d /usr/local/bin
        fi
        terraform -version
      displayName: "Install Terraform $(TF_VERSION)"

    # Use Azure CLI with OIDC to create the backend resources
    - task: AzureCLI@2
      displayName: "Create/ensure backend resources"
      inputs:
        azureSubscription: ${{ variables.SERVICE_CONNECTION }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          # Compute environment and location strings
          ENV="$(ENV_NAME)"
          LOC_RAW="$(LOCATION)"
          # Lowercase the location for naming purposes
          LOC="${LOC_RAW,,}"

          # Determine the resource group.  Dev and stage share a fixed
          # group name; prod uses a dynamic pattern.
          if [[ "${{ parameters.envName }}" == "dev" || "${{ parameters.envName }}" == "stage" ]]; then
            RG="dev-eus2-ops-rg-1"
          else
            RG="${ENV}-${LOC}-ops-rg-1"
          fi

          # Construct a compliant storage account name.  Azure requires
          # storage account names to be 3-24 characters, lowercase,
          # letters and numbers only.  We prefix with "st" for
          # uniqueness and remove dashes.
          SA="st${ENV}tfstate${LOC}"
          SA="${SA,,}"

          # Container name may include a dash and must be lowercase
          CONT="${ENV}-tfstate"
          CONT="${CONT,,}"

          # Optionally ensure the resource group exists
          az group create -n "$RG" -l "$(LOCATION)"

          # Create the storage account if it doesn't exist
          if ! az storage account show -n "$SA" -g "$RG" >/dev/null 2>&1; then
            az storage account create -n "$SA" -g "$RG" -l "$(LOCATION)" --sku Standard_LRS --kind StorageV2
          fi

          # Create the blob container if it doesn't exist.  Using
          # `az storage container create` returns success even if the
          # container already exists.
          az storage container create --account-name "$SA" --name "$CONT" >/dev/null 2>&1 || true

          # Optionally ensure the Key Vault exists if specified.  Some
          # environments may not define TFSTATE_KV_NAME.
          KV_NAME="$(TFSTATE_KV_NAME)"
          if [[ -n "$KV_NAME" ]]; then
            if ! az keyvault show -n "$KV_NAME" -g "$RG" >/dev/null 2>&1; then
              az keyvault create -n "$KV_NAME" -g "$RG" -l "$(LOCATION)" \
                --enable-soft-delete true --enable-purge-protection true
            fi
          fi

# -------------------------------------------------------------------------
# Plan stage: init and plan the Terraform configuration for the env
# -------------------------------------------------------------------------
- stage: Plan
  displayName: "Plan (${{ parameters.envName }}, state-only)"
  dependsOn: Bootstrap
  jobs:
  - job: plan
    displayName: "terraform plan (env: ${{ parameters.envName }})"
    steps:
    - checkout: self

    # Ensure Terraform is installed
    - bash: |
        set -euo pipefail
        TFV="${TF_VERSION:-1.9.5}"
        if ! command -v terraform >/dev/null 2>&1 || ! terraform version | head -1 | grep -q "v${TFV}"; then
          sudo apt-get update -y && sudo apt-get install -y unzip curl
          curl -fsSL -o /tmp/tf.zip "https://releases.hashicorp.com/terraform/${TFV}/terraform_${TFV}_linux_amd64.zip"
          sudo unzip -o /tmp/tf.zip -d /usr/local/bin
        fi
      displayName: "Install Terraform $(TF_VERSION)"

    - task: AzureCLI@2
      displayName: "terraform init, validate, plan (env: ${{ parameters.envName }})"
      inputs:
        azureSubscription: ${{ variables.SERVICE_CONNECTION }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail

          # Compute environment and location for backend names
          ENV="$(ENV_NAME)"
          LOC_RAW="$(LOCATION)"
          LOC="${LOC_RAW,,}"
          if [[ "${{ parameters.envName }}" == "dev" || "${{ parameters.envName }}" == "stage" ]]; then
            RG="dev-eus2-ops-rg-1"
          else
            RG="${ENV}-${LOC}-ops-rg-1"
          fi
          SA="st${ENV}tfstate${LOC}"; SA="${SA,,}"
          CONT="${ENV}-tfstate"; CONT="${CONT,,}"
          KEY="arbit/${ENV}.tfstate"

          # Normalize lock timeout: treat bare numbers as minutes
          LOCK="${TF_LOCK_TIMEOUT:-20m}"
          [[ "$LOCK" =~ ^[0-9]+$ ]] && LOCK="${LOCK}m"

          export ARM_USE_OIDC=true
          export ARM_SUBSCRIPTION_ID="$(AZ_SUBSCRIPTION_ID)"

          cd "envs/${{ parameters.envName }}"
          terraform init -reconfigure \
            -backend-config="resource_group_name=${RG}" \
            -backend-config="storage_account_name=${SA}" \
            -backend-config="container_name=${CONT}" \
            -backend-config="key=${KEY}" \
            -backend-config="use_azuread_auth=true" \
            -lock-timeout="$LOCK"

          terraform validate
          terraform plan -input=false -var-file="terraform.tfvars" -out "$(Pipeline.Workspace)/${{ parameters.envName }}.tfplan"

    - task: PublishPipelineArtifact@1
      displayName: "Publish plan artifact"
      inputs:
        targetPath: "$(Pipeline.Workspace)/${{ parameters.envName }}.tfplan"
        artifact: "tfplan-${{ parameters.envName }}"

# -------------------------------------------------------------------------
# Apply stage: apply the previously produced plan
# -------------------------------------------------------------------------
- stage: Apply
  displayName: "Apply (${{ parameters.envName }})"
  dependsOn: Plan
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: apply
    displayName: "terraform apply (env: ${{ parameters.envName }})"
    steps:
    - checkout: self

    - task: DownloadPipelineArtifact@2
      displayName: "Download plan artifact"
      inputs:
        buildType: current
        artifact: "tfplan-${{ parameters.envName }}"
        downloadPath: "$(Pipeline.Workspace)/plans"

    - task: AzureCLI@2
      displayName: "Apply plan"
      inputs:
        azureSubscription: ${{ variables.SERVICE_CONNECTION }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail

          # Compute backend names again (as above)
          ENV="$(ENV_NAME)"
          LOC_RAW="$(LOCATION)"
          LOC="${LOC_RAW,,}"
          if [[ "${{ parameters.envName }}" == "dev" || "${{ parameters.envName }}" == "stage" ]]; then
            RG="dev-eus2-ops-rg-1"
          else
            RG="${ENV}-${LOC}-ops-rg-1"
          fi
          SA="st${ENV}tfstate${LOC}"; SA="${SA,,}"
          CONT="${ENV}-tfstate"; CONT="${CONT,,}"
          KEY="arbit/${ENV}.tfstate"

          export ARM_USE_OIDC=true
          export ARM_SUBSCRIPTION_ID="$(AZ_SUBSCRIPTION_ID)"

          cd "envs/${{ parameters.envName }}"
          terraform init -reconfigure \
            -backend-config="resource_group_name=${RG}" \
            -backend-config="storage_account_name=${SA}" \
            -backend-config="container_name=${CONT}" \
            -backend-config="key=${KEY}" \
            -backend-config="use_azuread_auth=true"

          terraform apply -input=false -auto-approve "$(Pipeline.Workspace)/plans/${{ parameters.envName }}.tfplan"
